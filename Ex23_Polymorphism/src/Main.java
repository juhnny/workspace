
public class Main {

	public static void main(String[] args) {
		
		// 다형성 [ Polymorphism ] - 코드 모양을 같은데 다른 결과가 나오는 것
		
		First f = new First();    //제대로 된 캐스팅[ casting ]
		Second s = new Second();  //제대로 된 캐스팅[ casting ]
		
		//다른 class의 객체는 캐스팅이 안되야 정상
		//하지만, 상속관계의 클래스라면 ....
		f = new Second(); //부모참조변수는 자식객체를 참조할 수 있음.    [업캐스팅]		
		//s= new First();  //자식참보변수가 부모객체를 참조할 수 없음!! [다운캐스팅]
		
		//부모참조변수로 자식객체를 참조할 수는 있지만
		//부모객체의 멤버만 제어할 수 있음.
		f.a = 10;
		f.showFirst();
		//자식객체만의 고유한 멤버들을 사용불가
		//f.showSecond();//억지로 써도 에러!!
		
		//그럼에도 Second의 멤버를 꼭 쓰고 싶다면.. 다운캐스팅이 필요하다.
		//그런데 다운캐스팅[형변환연산]은 반드시 한번은 업캐스팅이 있어야만 할 수 있다!
		//부모 객체보다 자식 객체에 기능이 보통 더 많은데 
		//부모 참조변수에 자식 객체를 담아두면 부모 객체인 줄 알고 써도 문제가 없으나
		//자식 참조변수에 부모 객체를 담아두면 자식 객체인 줄 알고 썼을 때 없는 멤버를 사용하려 할 수 있다.
		
		//기본형 자료형들도 작은 자료형에서 큰 자료형으로는 자동 형변환이 되지만 반대의 경우 명시적 형변환이 필요하다. 비슷한 원리라고 볼 수 있다.
		int n = 10;
		double d = 3.14;
		d = n;
		n = (int)d;
		System.out.println("d: "+d);
		System.out.println("n: "+n);
		
		//참고로 형변환시 피연산자의 자료형을 직접 바꾸는 게 아니다. 형변환된 데이터를 메모리에 하나 더 만들고 그 값을 이용하는 것.
		
		//업캐스팅 없이 바로 다운캐스팅 하려는 경우 1
		First f2 = new First(); //제대로 된 캐스팅
		Second s2;
//		s2 = (Second)f2; //다운캐스팅 에러. class First cannot be cast to class Second
		//f2가 "이거 Second 주소야"라고 알려준 주소에 가보니 First 객체가 있으니, First 클래스를 Second 클래스의 틀에 넣을 수 없다는 뜻
		
		//업캐스팅 없이 바로 다운캐스팅 하려는 경우 2
		Second s3;
//		s3 = (Second)(new First()); //다운캐스팅 에러. class First cannot be cast to class Second
		
		//업캐스팅을 먼저 해주는 경우
		First f3 = new Second(); //자식 객체를 먼저 만들어 업캐스팅
		Second s4; //자식 참조변수
//		s4 = f3; //참조변수와 객체의 타입이 같음에도 그냥 넣으려고 하면 에러 [why? 자식참조변수가 부모객체를 참조한다고 생각함] 
				//컴퓨터가 보는 건 s4 = f3라는 명령 뿐이다. f3가 Second 객체를 가리키고 있다는 걸 모른다. s4와 f3의 타입이 다르다는 것만 인지한다. 
		s4 = (Second)f3; //다운캐스팅 가능 - [형변환연산자가 필요]
		s4.showSecond(); //자식 객체 고유 기능 사용
		
		//혹은 이렇게 자식 참조변수 없이 형변환 연산자만으로 다운캐스팅 가능
		((Second)f3).showSecond(); //자식 객체 고유 기능 사용
		
		//그런데 똑같이 부모 참조변수에 형변환을 해줬는데 왜 한번 자식 객체를 가리켜본(업캐스팅) 참조변수만 다운캐스팅이 가능할까?
		//부모 참조변수가 자식 객체를 가리켜봤는지 아닌지를 정보로 보관하고 있는게 아니다. 그럴 리가 없지.
		//s2 = (Second)f2 가 문법적으로 에러가 아니라는 건 다운캐스팅 자체는 된다는 것을 보여준다. 
		//하지만 s2 입장에서는 f2가 Second 객체를 가리킨다고 해서 가봤는데 Second 객체가 없으니까 에러가 나는 것.
		//그러니 원래 f2가 가리키는 곳에 원래 Second 객체가 있었던 경우(업캐스팅)에만 에러가 안 나는 것이다.
		//업캐스팅은 원래 부모가 가진 기능이 자식보다 적으니 부모 참조변수가 자식 객체를 가리켜도 문제가 없겠다 싶어서 문법적으로 허용해준 것이고
		//다운캐스팅은 그것이 성공하려면 부모 참조변수가 원래부터 이제 가리키려는 클래스를 가리키고 있었어야 하는 것이다.
		
		
		//여기까지 하고나면..업캐스팅을 왜하지?
		//이걸 알려면.. 먼저 확인할 사항이 있음.
		//메소드 오버라이드된 기능이 있다면..??
		First f4 = new Second();
		f4.show(); //실제 참조하는 객체의 오버라이드된 메소드가 발동함! [부모참조변수로 자식객체의 멤버기능을 사용한 모습이 됨]
		
		System.out.println("======================");
		//이 기술이 어떨때 유용한가??
		
		//부모참조변수 1개를 가지고 자식객체 모두를 제어할때
		First obj; //부모참조변수 1개
		
		obj = new First();
		obj.show();
		
		obj = new Second(); //업캐스팅
		obj.show(); //오버라이드된 show()발동
		
		//조부모가 손주를 참조가능(업캐스팅)
		obj = new Third();
		obj.show();
		
		//위처럼 obj.show();의 코드모양은 똑같은 다른 결과(다른 객체의 기능)가 보인다고 해서 "다형성"이라고 부름
		
		//다형성을 사용하는 예제..다음 프로젝트
		

	}

}
